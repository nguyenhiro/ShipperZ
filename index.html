<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game ShipperZ Vui V·∫ª</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87ceeb;
            background-image: url('body.jpg'); /* ƒê∆∞·ªùng d·∫´n ƒë·∫øn ·∫£nh n·ªÅn b·∫°n mu·ªën */
            background-size: cover; /* Ho·∫∑c contain, ho·∫∑c 100% 100% t√πy √Ω */
            background-repeat: no-repeat;
            background-position: center center;
    /* backdrop-filter: brightness(0.5); */ /* T√πy ch·ªçn: L√†m m·ªù ho·∫∑c t·ªëi ·∫£nh n·ªÅn */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #game-container {
            width: 900px;
            height: 450px;
            border: 5px solid #333;
            background-color: #aaddff;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #game-world {
            position: absolute;
            top: 0;
            left: 0;
            width: 2500px;
            height: 100%;
            transition: transform 0.1s linear;
            background-image: url('viahe1.jpg');
            background-size: 500px 100%; /* ƒê·∫∑t chi·ªÅu r·ªông c·ªë ƒë·ªãnh cho m·ªói ƒë∆°n v·ªã l·∫∑p l·∫°i */
            background-repeat: repeat-x;
            background-position: center bottom;
            image-rendering: -webkit-optimize-contrast; /* L√†m s·∫Øc n√©t h√¨nh ·∫£nh tr√™n Chrome */
            image-rendering: crisp-edges; /* L√†m s·∫Øc n√©t h√¨nh ·∫£nh tr√™n Firefox */
            background-color: #2c1810;
        }
        
        /* Th√™m l·ªõp overlay ƒë·ªÉ t·∫°o ƒë·ªô s√¢u v√† ƒë·ªìng nh·∫•t */
        #game-world::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(0deg, 
                rgba(0,0,0,0.2) 0%,
                rgba(0,0,0,0.1) 20%,
                rgba(0,0,0,0) 50%,
                rgba(0,0,0,0.1) 80%,
                rgba(0,0,0,0.2) 100%
            );
            pointer-events: none;
            z-index: 3;
        }

        #player {
            width: 130px;
            height: 130px;
            background-image: url('nhanvat.png');
            background-size: contain;
            background-position: center bottom;
            background-repeat: no-repeat;
            position: absolute;
            image-rendering: pixelated;
            z-index: 10;
        }

        #player.flipped {
            transform: scaleX(-1);
        }

        .platform {
            position: absolute;
            height: 50px;
            z-index: 5;
            background: none;
            background-color: transparent;
            border: none;
            pointer-events: auto;
            /* Ensure platforms with images show cleanly */
            background-repeat: no-repeat;
            background-position: center bottom;
            background-size: contain;
        }

        /* Th√™m style cho platform c√≥ th·ªÉ xuy√™n qua (h·ªë s√¢u) */
        .passthrough-platform {
            position: absolute;
            height: 40px;
            z-index: 4;
            background-image: url('ongnuoc.png'); /* H√¨nh ·∫£nh c·ªëng n∆∞·ªõc */
            background-size: 100% 100%;
            background-repeat: no-repeat;
            opacity: 0.9;
            pointer-events: none; /* Cho ph√©p xuy√™n qua */
        }

        /* Th√™m hi·ªáu ·ª©ng c·∫£nh b√°o cho h·ªë s√¢u */
        .passthrough-platform::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 0;
            right: 0;
            height: 10px;
            background: linear-gradient(to bottom,
                rgba(255, 0, 0, 0.2),
                rgba(255, 0, 0, 0)
            );
            animation: warning 1s infinite;
        }

        @keyframes warning {
            0% { opacity: 0.3; }
            50% { opacity: 0.7; }
            100% { opacity: 0.3; }
        }
        
        /* Th√™m hi·ªáu ·ª©ng cho kho·∫£ng tr·ªëng gi·ªØa c√°c platform */
        #game-world::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(0deg, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0) 50%);
            pointer-events: none;
            z-index: 4;
        }

        .obstacle, .hazard, .moving-obstacle {
            background-color: #8B4513;
            position: absolute;
            background-image: url('khucgo.jpg'); /* Thay ƒë·ªïi ƒë∆∞·ªùng d·∫´n ·∫£nh t·∫°i ƒë√¢y */
            background-size: cover; /* Ho·∫∑c '100% 100%' ho·∫∑c 'contain' t√πy √Ω b·∫°n mu·ªën ·∫£nh hi·ªÉn th·ªã */
            background-repeat: repeat-x; /* ƒê·ªÉ ·∫£nh l·∫∑p l·∫°i theo chi·ªÅu ngang n·∫øu platform d√†i h∆°n ·∫£nh */
            border: 2px solid #555;
            z-index: 6;
        }
        .hazard {
            /* Make hazard container visually transparent so the hazard sprite is shown cleanly */
            background-color: transparent;
            border: none;
            background-repeat: no-repeat;
            background-position: center bottom;
            z-index: 6;
        }
        .moving-obstacle {
            /* Make moving obstacle container visually transparent so only the sprite image is visible */
            background-color: transparent;
            border: none;
            background-repeat: no-repeat;
            background-position: center bottom;
            /* background-size handled per-element in createLevel (contain) to preserve aspect ratio */
            z-index: 6;
        }

        #finish-line {
            width: 400px;
            height: 400px;
            background-color: transparent;
            position: absolute;
            background-image: url('hopbian.png'); /* Thay ƒë·ªïi ƒë∆∞·ªùng d·∫´n ·∫£nh t·∫°i ƒë√¢y */
            background-size: contain; /* ƒê·ªÉ gi·ªØ t·ª∑ l·ªá ·∫£nh */
            background-repeat: no-repeat; /* Kh√¥ng l·∫∑p l·∫°i ·∫£nh */
            background-position: center;
            border: none;
            z-index: 7;
        }

        #game-info {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: 'Roboto', sans-serif;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #music-toggle-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 15px;
            background-color: #f7931e; /* M√†u cam n·ªïi b·∫≠t */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-weight: bold;
            font-size: 0.9em;
            z-index: 50; /* ƒê·∫£m b·∫£o n√∫t n·∫±m tr√™n m·ªçi th·ª© */
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: background-color 0.2s;
        }

        #music-toggle-button:hover {
            background-color: #e5820d;
        }
        #time-display, #level-display {
            font-weight: bold;
            font-size: 1.2em;
            color: white;
            text-shadow: 2px 2px 3px black;
        }

        #reset-character {
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }

        #reset-character:hover {
            background-color: #45a049;
        }

        /* Mobile jump button (right side) */
        #jump-button {
            position: absolute;
            right: 14px;
            bottom: 60px;
            width: 92px;
            height: 92px;
            border-radius: 50%;
            background: rgba(0,0,0,0.35);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-family: 'Roboto', sans-serif;
            z-index: 30;
            touch-action: none; /* prevent default scrolling while touching */
            user-select: none;
            -webkit-user-select: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }

        #jump-button:active {
            background: rgba(255,255,255,0.12);
            transform: translateY(1px);
        }
        
        /* Left-side joystick container */
        #joystick {
            position: absolute;
            left: 14px;
            bottom: 40px;
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background: rgba(0,0,0,0.18);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 29;
            touch-action: none;
        }

        #joystick-knob {
            width: 62px;
            height: 62px;
            border-radius: 50%;
            background: rgba(255,255,255,0.18);
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
            transition: transform 0.06s linear;
            pointer-events: none; /* knob moves visually but events are on container */
        }

        /* Controls description placed below Reset Nh√¢n V·∫≠t */
        #controls-desc {
            font-size: 0.9em;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            max-width: 260px;
            line-height: 1.2;
        }

        #game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px 60px;
            border-radius: 15px;
            font-family: 'Roboto', sans-serif;
            font-size: 2.2em;
            display: none;
            z-index: 100;
            text-align: center;
            border: 3px solid #ffcc00;
            text-shadow: 2px 2px 5px black;
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.6);
        }
        #game-message p {
            margin-bottom: 15px;
            font-size: 0.8em;
            font-weight: bold;
        }
        #game-message ul {
            list-style: none;
            padding: 0;
            margin-top: 10px;
            font-size: 0.6em;
            max-height: 100px;
            overflow-y: auto;
            border-top: 1px dashed rgba(255,255,255,0.3);
            padding-top: 10px;
        }
        #game-message li {
            margin-bottom: 3px;
        }

        #reset-button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            transition: background-color 0.2s, transform 0.2s;
            font-family: 'Roboto', sans-serif;
        }
        #reset-button:hover {
            background-color: #45a049;
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-world">
            <div id="player"></div>
            <div id="finish-line"></div>
        </div>
    <div id="music-toggle-button" role="button" aria-label="B·∫≠t T·∫Øt Nh·∫°c">
            üîä B·∫¨T NH·∫†C
        </div>
        <!-- Left-side touch joystick for movement -->
        <div id="joystick" aria-hidden="false">
            <div id="joystick-knob"></div>
        </div>
        <!-- Right-side jump button for mobile -->
        <div id="jump-button" role="button" aria-label="Nh·∫£y">NH·∫¢Y</div>
    </div>

    <div id="game-info">
        <div id="time-display">Th·ªùi gian: 00:00</div>
        <div id="level-display">M√†n: 1</div>
        <button id="reset-character" onclick="resetCharacter()">Reset Nh√¢n V·∫≠t</button>
        <div id="controls-desc">
            H∆∞·ªõng d·∫´n: A / D ho·∫∑c ‚Üê / ‚Üí ƒë·ªÉ di chuy·ªÉn. Space ho·∫∑c ch·∫°m n√∫t "NH·∫¢Y" ƒë·ªÉ nh·∫£y. Nh·∫•n "Reset Nh√¢n V·∫≠t" ƒë·ªÉ quay v·ªÅ nh√¢n v·∫≠t m·∫∑c ƒë·ªãnh.
        </div>
    </div>
    <div id="game-message">
        <p>B·∫°n ƒë√£ chi·∫øn th·∫Øng!</p>
        <button id="reset-button">Ch∆°i L·∫°i</button>
    </div>
    <audio id="background-music" loop>
        <source src="giangsinh.mp3" type="audio/mpeg"> 
        Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ th·∫ª audio.
    </audio>
    <script>
    const music = document.getElementById('background-music');
    const musicToggleButton = document.getElementById('music-toggle-button');
    let isMusicPlaying = false;

    /**
     * H√†m chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i B·∫≠t/T·∫Øt nh·∫°c n·ªÅn.
     * S·ª≠ d·ª•ng .play() khi b·∫≠t ƒë·ªÉ v∆∞·ª£t qua ch√≠nh s√°ch Autoplay.
     */
    function toggleMusic() {
        if (!musicToggleButton || !music) return;
        
        if (isMusicPlaying) {
            // Tr∆∞·ªùng h·ª£p 1: ƒêang ph√°t -> T·∫ÆT NH·∫†C
            music.pause();
            isMusicPlaying = false;
            musicToggleButton.textContent = 'üîä B·∫¨T NH·∫†C';
            musicToggleButton.style.backgroundColor = '#f7931e'; // M√†u B·∫≠t
        } else {
            // Tr∆∞·ªùng h·ª£p 2: ƒêang t·∫Øt -> B·∫¨T NH·∫†C
            music.volume = 0.5; // ƒê·∫∑t √¢m l∆∞·ª£ng 50%
            
            music.play().then(() => {
                // K√≠ch ho·∫°t th√†nh c√¥ng
                isMusicPlaying = true;
                musicToggleButton.textContent = 'üîá T·∫ÆT NH·∫†C';
                musicToggleButton.style.backgroundColor = '#d9534f'; // M√†u T·∫Øt
            }).catch(error => {
                // X·ª≠ l√Ω l·ªói n·∫øu tr√¨nh duy·ªát ch·∫∑n ph√°t (d√π ƒë√£ c√≥ t∆∞∆°ng t√°c)
                console.error("L·ªói khi c·ªë g·∫Øng ph√°t nh·∫°c. Vui l√≤ng th·ª≠ l·∫°i.", error);
                alert("Tr√¨nh duy·ªát kh√¥ng cho ph√©p ph√°t nh·∫°c ngay l·∫≠p t·ª©c. H√£y ƒë·∫£m b·∫£o b·∫°n ƒë√£ nh·∫•n n√∫t n√†y l·∫ßn ƒë·∫ßu ƒë·ªÉ k√≠ch ho·∫°t.");
            });
        }
    }

    // G·∫Øn s·ª± ki·ªán v√†o n√∫t cho c·∫£ PC (click) v√† Mobile (touchstart)
    musicToggleButton.addEventListener('click', toggleMusic);
    musicToggleButton.addEventListener('touchstart', (e) => {
        // e.preventDefault() c·∫ßn thi·∫øt ƒë·ªÉ ngƒÉn ch·∫∑n s·ª± ki·ªán ch·∫°m g√¢y ra scroll tr√™n di ƒë·ªông
        e.preventDefault(); 
        toggleMusic();
    });

    // ... (logic game c·ªßa b·∫°n ti·∫øp t·ª•c t·ª´ ƒë√¢y)
                /*
                 Image notes:
                 - For best visual results, use images with transparent backgrounds (PNG with alpha) for obstacles
                     and moving sprites. If your files have white/solid backgrounds, remove them with tools such as:
                     * Photopea (photopea.com) ‚Äî free online editor: open image -> Select subject / Magic cut -> export PNG
                     * remove.bg (remove.bg) ‚Äî automatic background removal
                 - Filenames used in this level: bongbong.png, cuncute.png, phancute.png, hopbian.png, ongnuoc.png
                 - Place these files in the same folder as `shipperz.html` and refresh the page.
                 - If an image still shows a solid background, provide a transparent version and I will wire it in.
                */
        const player = document.getElementById('player');
        const gameContainer = document.getElementById('game-container');
        const gameWorld = document.getElementById('game-world');
        const finishLine = document.getElementById('finish-line');
        const gameMessage = document.getElementById('game-message');
        const timeDisplay = document.getElementById('time-display');
        const levelDisplay = document.getElementById('level-display');
        
        // Theo d√µi lo·∫°i nh√¢n v·∫≠t v√† level game
        let currentCharacter = 'nhanvat.png';
        let gameLevel = 1;
        const MAX_LEVEL = 5;
        const TIME_LIMIT = 60000; // 60 seconds in milliseconds
        
        // Mapping c√°c nh√¢n v·∫≠t theo level
        const characterProgression = {
            1: 'nhanvat.png',
            2: 'chuquan.png',
            3: 'cogiao.png',
            4: 'bodoi.png',
            5: 'bacsi.png'
        };

        // H√†m reset nh√¢n v·∫≠t v·ªÅ ban ƒë·∫ßu
        function resetCharacter() {
            currentCharacter = 'nhanvat.png';
            gameLevel = 1;
            localStorage.setItem('currentCharacter', currentCharacter);
            localStorage.setItem('gameLevel', gameLevel);
            player.style.backgroundImage = `url('${currentCharacter}')`;
            updateLevelDisplay();
            resetTimer();
        }

        function updateLevelDisplay() {
            levelDisplay.textContent = `M√†n: ${gameLevel}`;
        }

        let startTime = 0;
        let elapsedTime = 0;
        let timerInterval;

        let winHistory = JSON.parse(localStorage.getItem('gameWinHistory')) || [];

        let playerX = 50;
        let playerY = 0;
        const playerBaseWidth = 60;
        const playerBaseHeight = 60;
        let playerActualWidth = playerBaseWidth;
        let playerActualHeight = playerBaseHeight;

        const hitboxXOffset = 10; // Kho·∫£ng c√°ch t·ª´ c·∫°nh player ƒë·∫øn hitbox (ngang)
        const hitboxYOffset = 5; // Kho·∫£ng c√°ch t·ª´ ƒë√°y player ƒë·∫øn hitbox (d·ªçc)

        // defaultGroundY KH√îNG C√íN ƒê∆Ø·ª¢C D√ôNG ƒê·ªÇ CH·∫∂N R∆†I N·ªÆA
        const defaultGroundY = 0; 

        // NG∆Ø·ª†NG R∆†I V·ª∞C: ƒê√£ ƒë·ªÉ l√† -100 nh∆∞ b·∫°n mu·ªën ki·ªÉm tra.
        const deathFallThreshold = -100; 

        let isJumping = false;
        let isMovingLeft = false;
        let isMovingRight = false;
        let isGameOver = false;
        let isOnPlatform = false; // Bi·∫øn global ƒë·ªÉ x√°c ƒë·ªãnh c√≥ ƒëang ƒë·ª©ng tr√™n platform hay kh√¥ng

        const moveAcceleration = 1.2;
        const friction = 0.8;
        const maxSpeed = 6;
        const jumpStrength = 14;
        const gravity = 0.6;
        let xVelocity = 0;
        let yVelocity = 0;

        let cameraX = 0;
        let facingRight = true;

        let lastFrameTime = 0;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;

        let gameElements = [];
        let movingObstacles = [];

        function createLevel(levelData) {
            gameElements.forEach(el => el.remove());
            gameElements = [];
            movingObstacles = [];

            finishLine.style.left = levelData.finishLine.left + 'px';
            finishLine.style.bottom = levelData.finishLine.bottom + 'px';
            finishLine.style.width = levelData.finishLine.width + 'px';
            finishLine.style.height = levelData.finishLine.height + 'px';
            
            // M·∫£ng ƒë·ªÉ l∆∞u c√°c platform xuy√™n qua ƒë∆∞·ª£c
            window.passthroughPlatforms = [];

            levelData.elements.forEach(data => {
                const el = document.createElement('div');
                el.classList.add(data.type);
                el.style.left = data.left + 'px';
                el.style.bottom = data.bottom + 'px';
                el.style.width = data.width + 'px';
                el.style.height = data.height + 'px';
                gameWorld.appendChild(el);
                gameElements.push(el);

                // Apply per-element images/styles when provided in level data
                if (data.image) {
                    // Special-case: for phancute images we insert an <img> inside the element so we can
                    // scale the visible sprite independently of the collision box (keeps collision precise)
                    if (data.type === 'hazard' && /phancute/i.test(data.image)) {
                        // create an img element for fine-grained control
                        const img = document.createElement('img');
                        img.src = data.image;
                        img.alt = '';
                        img.style.position = 'absolute';
                        img.style.left = '50%';
                        img.style.transform = 'translateX(-50%)';
                        img.style.bottom = '0';
                        img.style.width = '80%'; // visible sprite will be 80% of container width
                        img.style.height = 'auto';
                        img.style.pointerEvents = 'none';
                        img.style.userSelect = 'none';
                        el.appendChild(img);
                        // keep container visually empty (no background)
                        el.style.backgroundImage = '';
                        el.style.backgroundSize = 'contain';
                    } else {
                        el.style.backgroundImage = `url('${data.image}')`;
                        el.style.backgroundRepeat = 'no-repeat';
                        el.style.backgroundPosition = 'center bottom';
                        // Preserve aspect ratio for moving obstacles and hazards so sprites don't distort
                        if (data.type === 'moving-obstacle' || data.type === 'hazard') {
                            el.style.backgroundSize = 'contain';
                        } else {
                            // Keep platform images looking clean with contain, others fill
                            if (data.type === 'platform') {
                                el.style.backgroundSize = 'contain';
                            } else {
                                el.style.backgroundSize = `${data.width}px ${data.height}px`;
                            }
                        }
                    }
                    // Keep border-free for hazards and platforms
                    if (data.type === 'hazard' || data.type === 'platform') {
                        el.style.border = 'none';
                        el.style.backgroundColor = 'transparent';
                    }
                }

                if (data.type === 'moving-obstacle') {
                    movingObstacles.push({
                        element: el,
                        initialLeft: data.left,
                        range: data.range,
                        speed: data.speed,
                        direction: 1,
                        pushForce: data.pushForce || 8
                    });
                }
            });
        }

        const level1Data = {
            worldWidth: 2500,
            finishLine: { left: 2450, bottom: 50, width: 50, height: 150 },
            elements: [
                // V·ªâa h√® ch√≠nh (chia ƒëo·∫°n ƒë·ªÉ t·∫°o h·ªë c·ªëng th·ª±c s·ª±)
                { type: 'platform', left: 0, width: 600, height: 50, bottom: 0, image: 'thungrac.png' },  /* 0..600 */
                { type: 'platform', left: 700, width: 400, height: 50, bottom: 0, image: 'thungrac.png' },/* 700..1100 */
                { type: 'platform', left: 1200, width: 400, height: 50, bottom: 0, image: 'thungrac.png' },/*1200..1600*/
                { type: 'platform', left: 1700, width: 300, height: 50, bottom: 0, image: 'thungrac.png' },/*1700..2000*/
                { type: 'platform', left: 2100, width: 400, height: 50, bottom: 0, image: 'thungrac.png' },/*2100..2500*/

                // H·ªë c·ªëng (platform xuy√™n qua ƒë∆∞·ª£c) - v·ªã tr√≠ t√°ch xa h∆°n ƒë·ªÉ kh√¥ng ch·ªìng ch√©o v·ªõi hazard
                { type: 'passthrough-platform', left: 600, width: 100, height: 40, bottom: 0, image: 'ongnuoc.png' },
                { type: 'passthrough-platform', left: 1100, width: 100, height: 40, bottom: 0, image: 'ongnuoc.png' },
                { type: 'passthrough-platform', left: 1600, width: 100, height: 40, bottom: 0, image: 'ongnuoc.png' },
                { type: 'passthrough-platform', left: 2000, width: 100, height: 40, bottom: 0, image: 'ongnuoc.png' },

                // C√°c v·∫≠t c·∫£n nguy hi·ªÉm (c√≥ th·ªÉ l√† ·ªï g√†, v≈©ng n∆∞·ªõc, etc.)
                // Hazards spaced away from holes
                { type: 'hazard', left: 350, width: 80, height: 80, bottom: 50, image: 'cuncute.png' },
                { type: 'hazard', left: 900, width: 50, height: 50, bottom: 50, image: 'phancute.png' },
                { type: 'hazard', left: 1500, width: 50, height: 50, bottom: 50, image: 'phancute.png' },
                { type: 'hazard', left: 2300, width: 50, height: 50, bottom: 50, image: 'phancute.png' },

                // V·∫≠t th·ªÉ di chuy·ªÉn (c√≥ th·ªÉ l√† ng∆∞·ªùi ƒëi b·ªô, xe ƒë·∫°p, etc.)
                // Use bongbong.png for moving obstacles; shrink the container so the sprite appears smaller
                { type: 'moving-obstacle', left: 500, width: 60, height: 60, bottom: 60, range: 120, speed: 1.2, pushForce: 8, image: 'bongbong.png' },
                { type: 'moving-obstacle', left: 1300, width: 60, height: 60, bottom: 60, range: 160, speed: 1.0, pushForce: 10, image: 'bongbong.png' },
                { type: 'moving-obstacle', left: 2100, width: 60, height: 60, bottom: 60, range: 120, speed: 1.5, pushForce: 9, image: 'bongbong.png' }
            ]
        };


        function updateTimer() {
            if (isGameOver) return;
            const currentTime = performance.now();
            const timeElapsed = currentTime - startTime;
            const timeRemaining = TIME_LIMIT - timeElapsed;
            
            if (timeRemaining <= 0) {
                endGame('H·∫øt th·ªùi gian! B·∫°n ƒë√£ thua.');
                return;
            }

            const seconds = Math.ceil(timeRemaining / 1000); // Round up to give player full second
            timeDisplay.textContent = `Th·ªùi gian: ${seconds}s`;

            // Th√™m hi·ªáu ·ª©ng nh·∫•p nh√°y khi g·∫ßn h·∫øt gi·ªù
            if (seconds <= 10) {
                timeDisplay.style.color = seconds % 2 === 0 ? 'red' : 'white';
            }
        }

        function resetTimer() {
            startTime = performance.now();
            timeDisplay.style.color = 'white';
        }

        function updatePlayerPosition() {
            player.style.left = playerX + 'px';
            player.style.bottom = playerY + 'px';

            if (xVelocity < 0 && facingRight) {
                player.classList.add('flipped');
                facingRight = false;
            } else if (xVelocity > 0 && !facingRight) {
                player.classList.remove('flipped');
                facingRight = true;
            }
        }

        function jump() {
            // Ki·ªÉm tra isOnPlatform thay v√¨ isJumping, ƒë·ªÉ cho ph√©p nh·∫£y l·∫°i ngay khi ch·∫°m ƒë·∫•t
            if (!isJumping && isOnPlatform) { 
                isJumping = true;
                yVelocity = jumpStrength;
                isOnPlatform = false; // Khi nh·∫£y, kh√¥ng c√≤n tr√™n platform n·ªØa
            }
        }

        function getElementRect(element) {
            const left = parseInt(element.style.left);
            const bottom = parseInt(element.style.bottom);
            const width = element.offsetWidth;
            const height = element.offsetHeight;
            const right = left + width;
            const top = bottom + height;
            return { left, right, bottom, top, width, height };
        }

        function checkCollisionsX() {
            if (isGameOver) return; // don't process collisions when game ended
            const playerHitbox = {
                left: playerX + hitboxXOffset,
                right: playerX + playerActualWidth - hitboxXOffset,
                bottom: playerY + hitboxYOffset,
                top: playerY + playerActualHeight
            };

            gameElements.forEach(element => {
                if (isGameOver) return; // stop processing further elements if game ended during loop
                const elementRect = getElementRect(element);

                const horizontalOverlap = playerHitbox.left < elementRect.right && playerHitbox.right > elementRect.left;
                const verticalOverlap = playerHitbox.top > elementRect.bottom && playerHitbox.bottom < elementRect.top;

                if (horizontalOverlap && verticalOverlap) {
                    if (element.classList.contains('hazard')) {
                        endGame('B·∫°n ƒë√£ ch·∫°m ch∆∞·ªõng ng·∫°i v·∫≠t nguy hi·ªÉm!');
                        if (isGameOver) return; // ensure we stop processing after calling endGame
                    }

                    if (element.classList.contains('moving-obstacle')) {
                        // T√¨m v·∫≠t th·ªÉ di chuy·ªÉn trong m·∫£ng movingObstacles
                        const movingObs = movingObstacles.find(obs => obs.element === element);
                        if (movingObs) {
                            // X√°c ƒë·ªãnh h∆∞·ªõng va ch·∫°m v√† ƒë·∫©y l√πi
                            const playerCenter = playerX + playerActualWidth / 2;
                            const obstacleCenter = elementRect.left + elementRect.width / 2;
                            const pushForce = movingObs.speed * (movingObs.pushForce || 8); // L·ª±c ƒë·∫©y m·∫∑c ƒë·ªãnh l√† 8

                            if (playerCenter < obstacleCenter) {
                                // ƒê·∫©y sang tr√°i
                                xVelocity = -pushForce;
                                playerX = elementRect.left - playerActualWidth - 5; // Th√™m kho·∫£ng c√°ch an to√†n
                            } else {
                                // ƒê·∫©y sang ph·∫£i
                                xVelocity = pushForce;
                                playerX = elementRect.right + 5; // Th√™m kho·∫£ng c√°ch an to√†n
                            }
                            
                            // Th√™m m·ªôt ch√∫t ƒë·ªô n·∫£y l√™n khi va ch·∫°m
                            if (yVelocity <= 0) {
                                yVelocity = 5;
                            }
                        }
                    } else if (element.classList.contains('platform') || element.classList.contains('obstacle')) {
                        if (xVelocity > 0) {
                            playerX = elementRect.left - (playerActualWidth - hitboxXOffset);
                            xVelocity = 0;
                        }
                        else if (xVelocity < 0) {
                            playerX = elementRect.right - hitboxXOffset;
                            xVelocity = 0;
                        }
                    }
                }
            });
        }

        function checkCollisionsY(previousPlayerY) {
            if (isGameOver) return; // skip Y-collision processing if game already ended
            let playerCurrentlyOnPlatform = false;
            let newPlayerY = playerY;

            // Ki·ªÉm tra va ch·∫°m t·ª´ d∆∞·ªõi l√™n (ƒë·ª•ng tr·∫ßn)
            if (yVelocity > 0) {
                const playerTopY = previousPlayerY + playerActualHeight;
                const playerFutureTopY = playerY + playerActualHeight;

                gameElements.forEach(element => {
                    if (element.classList.contains('platform') || element.classList.contains('obstacle') || element.classList.contains('moving-obstacle')) {
                        const elementRect = getElementRect(element);
                        
                        // C·∫£i thi·ªán ph√°t hi·ªán va ch·∫°m ngang
                        const horizontalOverlap = (
                            playerX + hitboxXOffset < elementRect.right &&
                            playerX + playerActualWidth - hitboxXOffset > elementRect.left
                        );

                        // C·∫£i thi·ªán ph√°t hi·ªán va ch·∫°m khi nh·∫£y l√™n
                        if (horizontalOverlap && 
                            playerFutureTopY >= elementRect.bottom && 
                            playerTopY <= elementRect.bottom) {
                            
                            if (element.classList.contains('hazard')) {
                                endGame('B·∫°n ƒë√£ ch·∫°m ch∆∞·ªõng ng·∫°i v·∫≠t nguy hi·ªÉm!');
                                return;
                            }
                            
                            newPlayerY = elementRect.bottom - playerActualHeight;
                            yVelocity = 0;
                        }
                    }
                });
            }

            // Ki·ªÉm tra va ch·∫°m t·ª´ tr√™n xu·ªëng (ƒë·ª©ng tr√™n platform)
            let highestPlatformY = -Infinity;
            let foundPlatformBelow = false;

            gameElements.forEach(element => {
                if (isGameOver) return; // stop processing if game ended
                if (element.classList.contains('platform') || element.classList.contains('obstacle') || element.classList.contains('moving-obstacle')) {
                    const elementRect = getElementRect(element);

                    // C·∫£i thi·ªán ph√°t hi·ªán va ch·∫°m ngang v·ªõi hitbox ch√≠nh x√°c h∆°n
                    const horizontalOverlap = (
                        playerX + hitboxXOffset < elementRect.right &&
                        playerX + playerActualWidth - hitboxXOffset > elementRect.left
                    );

                    // C·∫£i thi·ªán logic ph√°t hi·ªán va ch·∫°m v·ªõi platform
                    const playerBottom = playerY + hitboxYOffset;
                    const previousPlayerBottom = previousPlayerY + hitboxYOffset;
                    
                    if (horizontalOverlap &&
                        yVelocity <= 0 && // ƒêang r∆°i ho·∫∑c ƒë·ª©ng y√™n
                        playerBottom <= elementRect.top + 5 && // Th√™m m·ªôt kho·∫£ng dung sai nh·ªè
                        previousPlayerBottom >= elementRect.top - 5) { // Th√™m m·ªôt kho·∫£ng dung sai nh·ªè

                        if (element.classList.contains('hazard')) {
                            endGame('B·∫°n ƒë√£ ch·∫°m ch∆∞·ªõng ng·∫°i v·∫≠t nguy hi·ªÉm!');
                            if (isGameOver) return; // N·∫øu game ƒë√£ over th√¨ d·ª´ng ngay
                        }

                        // N·∫øu t√¨m th·∫•y m·ªôt platform h·ª£p l·ªá ƒë·ªÉ ƒë·ª©ng, c·∫≠p nh·∫≠t highestPlatformY
                        // L·∫•y platform cao nh·∫•t m√† player c√≥ th·ªÉ ƒë·ª©ng l√™n
                        if (elementRect.top > highestPlatformY) {
                            highestPlatformY = elementRect.top;
                            foundPlatformBelow = true;
                        }
                    }
                }
            });

            // Sau khi duy·ªát qua t·∫•t c·∫£ c√°c ph·∫ßn t·ª≠, m·ªõi quy·∫øt ƒë·ªãnh v·ªã tr√≠ cu·ªëi c√πng c·ªßa playerY
            if (foundPlatformBelow) {
                newPlayerY = highestPlatformY - hitboxYOffset;
                yVelocity = 0;
                isJumping = false;
                playerCurrentlyOnPlatform = true;
            } else {
                // N·∫øu kh√¥ng t√¨m th·∫•y platform n√†o b√™n d∆∞·ªõi, player ƒëang r∆°i t·ª± do.
                playerCurrentlyOnPlatform = false;
            }

            playerY = newPlayerY;
            isOnPlatform = playerCurrentlyOnPlatform; // C·∫≠p nh·∫≠t bi·∫øn global isOnPlatform

            // --- DEBUG LOGS (Gi·ªØ nguy√™n ho·∫∑c c·∫£i thi·ªán) ---
            console.log(`--- Y-COLLISION DEBUG ---`);
            console.log(`playerY: ${playerY.toFixed(2)}, hitboxYOffset: ${hitboxYOffset}, defaultGroundY: ${defaultGroundY}, deathFallThreshold: ${deathFallThreshold}`);
            console.log(`yVelocity: ${yVelocity.toFixed(2)}, isJumping: ${isJumping}, isOnPlatform: ${isOnPlatform}, isGameOver: ${isGameOver}`);
            console.log(`ƒê√°y hitbox player: ${playerY + hitboxYOffset}`);
            
            const isFallingIntoDeathZone = (playerY + hitboxYOffset < deathFallThreshold);
            
            if (isFallingIntoDeathZone) {
                console.log("-> ƒê√°y hitbox th·∫•p h∆°n ng∆∞·ª°ng r∆°i v·ª±c!");
            } else {
                console.log("-> ƒê√°y hitbox v·∫´n n·∫±m tr√™n ng∆∞·ª°ng r∆°i v·ª±c."); 
            }

            if (!isOnPlatform) {
                console.log("-> Kh√¥ng ƒë·ª©ng tr√™n platform!");
            }
            if (!isGameOver) {
                console.log("-> Game ch∆∞a k·∫øt th√∫c!");
            }
            console.log("K·∫øt qu·∫£ ƒëi·ªÅu ki·ªán r∆°i v·ª±c:", isFallingIntoDeathZone);
            console.log(`-------------------------`);
            // --- END DEBUG LOGS ---

            // Ki·ªÉm tra r∆°i xu·ªëng v·ª±c cu·ªëi c√πng - ƒê·∫∑t sau khi ƒë√£ x·ª≠ l√Ω va ch·∫°m Y
            if (isFallingIntoDeathZone && !isGameOver) { 
                console.log("K√çCH HO·∫†T ENDGAME DO R∆†I V·ª∞C!"); 
                endGame('B·∫°n ƒë√£ r∆°i xu·ªëng v·ª±c!');
                return; // Tho√°t kh·ªèi h√†m ƒë·ªÉ tr√°nh c√°c t√≠nh to√°n kh√¥ng c·∫ßn thi·∫øt sau khi game over
            }
        }


        function checkWin() {
            const finishLineRect = getElementRect(finishLine);

            const playerHitbox = {
                left: playerX + hitboxXOffset,
                right: playerX + playerActualWidth - hitboxXOffset,
                bottom: playerY + hitboxYOffset,
                top: playerY + playerActualHeight
            };

            if (playerHitbox.left < finishLineRect.right &&
                playerHitbox.right > finishLineRect.left &&
                playerHitbox.bottom < finishLineRect.top &&
                playerHitbox.top > finishLineRect.bottom ) {

                if (!isGameOver) {
                    endGame('B·∫°n ƒë√£ chi·∫øn th·∫Øng!');
                }
            }
        }

        function endGame(message) {
            isGameOver = true;
            clearInterval(timerInterval);

            let finalMessage = `<p>${message}</p>`;
            let newRecord = false;

            if (message.includes('chi·∫øn th·∫Øng')) {
                const finalTime = elapsedTime;
                winHistory.push(finalTime);
                winHistory.sort((a, b) => a - b);
                if (winHistory.length > 5) {
                    winHistory = winHistory.slice(0, 5);
                }
                localStorage.setItem('gameWinHistory', JSON.stringify(winHistory));

                const minutes = Math.floor(finalTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                const milliseconds = Math.floor((elapsedTime % 1000) / 10);
                const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(2, '0')}`;

                finalMessage += `<p>Th·ªùi gian c·ªßa b·∫°n: ${formattedTime}</p>`;

                // Check for new record by comparing with the best time in history
                if (winHistory.length > 0 && finalTime === winHistory[0]) {
                    newRecord = true;
                }

                if (newRecord) {
                    finalMessage += `<p>K·ª∑ l·ª•c m·ªõi!</p>`;
                }

                // Thay ƒë·ªïi nh√¢n v·∫≠t khi chi·∫øn th·∫Øng
                if (gameLevel < MAX_LEVEL) {
                    gameLevel++;
                    currentCharacter = characterProgression[gameLevel];
                    finalMessage += `<p>Ch√∫c m·ª´ng! B·∫°n ƒë√£ m·ªü kh√≥a nh√¢n v·∫≠t m·ªõi!</p>`;
                    finalMessage += `<p>Nh√¢n v·∫≠t ti·∫øp theo: ${currentCharacter}</p>`;
                    player.style.backgroundImage = `url('${currentCharacter}')`;
                    // L∆∞u tr·∫°ng th√°i nh√¢n v·∫≠t
                    localStorage.setItem('currentCharacter', currentCharacter);
                    localStorage.setItem('gameLevel', gameLevel);
                } else {
                    finalMessage += `<p>Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh t·∫•t c·∫£ c√°c m√†n ch∆°i!</p>`;
                }
            }

            finalMessage += '<p>L·ªãch s·ª≠ chi·∫øn th·∫Øng:</p><ul>';
            if (winHistory.length === 0) {
                finalMessage += '<li>Ch∆∞a c√≥ k·ª∑ l·ª•c n√†o.</li>';
            } else {
                winHistory.forEach((time, index) => {
                    const minutes = Math.floor(time / 60000);
                    const seconds = Math.floor((time % 60000) / 1000);
                    const milliseconds = Math.floor((time % 1000) / 10);
                    const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(2, '0')}`;
                    finalMessage += `<li>${index + 1}. ${formattedTime}</li>`;
                });
            }
            finalMessage += '</ul>';


            finalMessage += '<button id="reset-button">Ch∆°i L·∫°i</button>';
            gameMessage.innerHTML = finalMessage;
            gameMessage.style.display = 'block';

            // G·ª° b·ªè v√† th√™m l·∫°i event listener ƒë·ªÉ tr√°nh vi·ªác g·∫Øn nhi·ªÅu l·∫ßn
            const existingResetButton = document.querySelector('#game-message #reset-button');
            if (existingResetButton) {
                existingResetButton.removeEventListener('click', initializeGame);
            }
            document.querySelector('#game-message #reset-button').addEventListener('click', initializeGame);

            cancelAnimationFrame(window.animationFrameId);
        }

        function gameLoop(currentTime) {
            if (isGameOver) return;

            const delta = (currentTime - lastFrameTime) / 1000; // delta in seconds
            lastFrameTime = currentTime;

            // C·∫≠p nh·∫≠t chuy·ªÉn ƒë·ªông c·ªßa c√°c v·∫≠t c·∫£n di chuy·ªÉn
            movingObstacles.forEach(obs => {
                const currentLeft = parseInt(obs.element.style.left);
                const maxLeft = obs.initialLeft + obs.range;
                const minLeft = obs.initialLeft;

                obs.element.style.left = currentLeft + (obs.speed * obs.direction * delta * targetFPS) + 'px';

                if (obs.direction === 1 && parseInt(obs.element.style.left) >= maxLeft) {
                    obs.direction = -1;
                    obs.element.style.left = maxLeft + 'px'; // Clamp position
                } else if (obs.direction === -1 && parseInt(obs.element.style.left) <= minLeft) {
                    obs.direction = 1;
                    obs.element.style.left = minLeft + 'px'; // Clamp position
                }
            });


            // --- X·ª¨ L√ù CHUY·ªÇN ƒê·ªòNG V√Ä VA CH·∫†M THEO T·ª™NG TR·ª§C ---

            // 1. C·∫≠p nh·∫≠t v√† x·ª≠ l√Ω chuy·ªÉn ƒë·ªông X
            if (isMovingLeft) {
                xVelocity = Math.max(-maxSpeed, xVelocity - moveAcceleration * delta * targetFPS);
            } else if (isMovingRight) {
                xVelocity = Math.min(maxSpeed, xVelocity + moveAcceleration * delta * targetFPS);
            } else {
                if (xVelocity > 0) {
                    xVelocity = Math.max(0, xVelocity - friction * delta * targetFPS);
                } else if (xVelocity < 0) {
                    xVelocity = Math.min(0, xVelocity + friction * delta * targetFPS);
                }
            }
            playerX += xVelocity;
            playerX = Math.max(0, Math.min(level1Data.worldWidth - playerActualWidth, playerX)); // ƒê·∫£m b·∫£o player kh√¥ng ra ngo√†i bi√™n th·∫ø gi·ªõi
            checkCollisionsX(); // Ki·ªÉm tra va ch·∫°m X sau khi di chuy·ªÉn X

            // 2. C·∫≠p nh·∫≠t v√† x·ª≠ l√Ω chuy·ªÉn ƒë·ªông Y (tr·ªçng l·ª±c v√† nh·∫£y)
            const previousPlayerY = playerY;
            playerY += yVelocity;
            yVelocity -= gravity * delta * targetFPS;
            checkCollisionsY(previousPlayerY); // Truy·ªÅn v·ªã tr√≠ Y tr∆∞·ªõc ƒë√≥ v√†o h√†m va ch·∫°m Y

            // C·∫≠p nh·∫≠t v·ªã tr√≠ hi·ªÉn th·ªã c·ªßa player
            updatePlayerPosition();

            // C·∫≠p nh·∫≠t camera
            const playerScreenX = playerX + cameraX;
            const cameraThreshold = gameContainer.offsetWidth / 3; // 1/3 m√†n h√¨nh t·ª´ m·ªói b√™n

            if (playerScreenX > gameContainer.offsetWidth - cameraThreshold && xVelocity > 0) {
                cameraX -= (playerScreenX - (gameContainer.offsetWidth - cameraThreshold));
            } else if (playerScreenX < cameraThreshold && xVelocity < 0) {
                cameraX += (cameraThreshold - playerScreenX);
            }

            // Gi·ªõi h·∫°n camera kh√¥ng ra ngo√†i bi√™n th·∫ø gi·ªõi
            cameraX = Math.min(0, cameraX); // Kh√¥ng cho camera v∆∞·ª£t qu√° 0 v·ªÅ b√™n tr√°i
            cameraX = Math.max(gameContainer.offsetWidth - level1Data.worldWidth, cameraX); // Kh√¥ng cho camera v∆∞·ª£t qu√° bi√™n ph·∫£i c·ªßa th·∫ø gi·ªõi

            gameWorld.style.transform = `translateX(${cameraX}px)`;

            checkWin();
            updateTimer();

            window.animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Keyboard controls (desktop + laptop)
        document.addEventListener('keydown', (event) => {
            if (isGameOver) return;

            switch (event.code) {
                case 'KeyA':
                case 'ArrowLeft':
                    isMovingLeft = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    isMovingRight = true;
                    break;
                case 'Space':
                    jump();
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (isGameOver) return;

            switch (event.code) {
                case 'KeyA':
                case 'ArrowLeft':
                    isMovingLeft = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    isMovingRight = false;
                    break;
            }
        });

        // Mobile / touch jump button handling
        const jumpButton = document.getElementById('jump-button');
        if (jumpButton) {
            const handleJumpStart = (e) => {
                // Prevent page scroll on touch
                if (e.cancelable) e.preventDefault();
                if (!isGameOver) jump();
                jumpButton.classList.add('active');
            };
            const handleJumpEnd = (e) => {
                if (e && e.cancelable) e.preventDefault();
                jumpButton.classList.remove('active');
            };

            // Touch events for mobile
            jumpButton.addEventListener('touchstart', handleJumpStart, { passive: false });
            jumpButton.addEventListener('touchend', handleJumpEnd);
            jumpButton.addEventListener('touchcancel', handleJumpEnd);

            // Mouse events for desktop / testing
            jumpButton.addEventListener('mousedown', handleJumpStart);
            document.addEventListener('mouseup', handleJumpEnd);
        }

        // Joystick handling for left-side movement (touch + mouse)
        const joystick = document.getElementById('joystick');
        const joystickKnob = document.getElementById('joystick-knob');
        if (joystick && joystickKnob) {
            let activeTouchId = null;
            let isPointerDown = false;

            const getLocalPos = (clientX, clientY) => {
                const r = joystick.getBoundingClientRect();
                return { x: clientX - (r.left + r.width / 2), y: clientY - (r.top + r.height / 2), radius: r.width / 2 };
            };

            const updateKnob = (dx, dy, radius) => {
                // limit knob travel to 40% of radius horizontally for visual clarity
                const max = radius * 0.45;
                const tx = Math.max(-max, Math.min(max, dx));
                const ty = Math.max(-max, Math.min(max, dy));
                joystickKnob.style.transform = `translate(${tx}px, ${ty}px)`;
            };

            const handleStart = (clientX, clientY, id) => {
                activeTouchId = id;
                isPointerDown = true;
                const p = getLocalPos(clientX, clientY);
                updateKnob(p.x, p.y, p.radius);
                // decide left/right based on x
                const dead = p.radius * 0.18;
                if (p.x < -dead) {
                    isMovingLeft = true;
                    isMovingRight = false;
                } else if (p.x > dead) {
                    isMovingRight = true;
                    isMovingLeft = false;
                } else {
                    isMovingLeft = false;
                    isMovingRight = false;
                }
            };

            const handleMove = (clientX, clientY) => {
                if (!isPointerDown) return;
                const p = getLocalPos(clientX, clientY);
                updateKnob(p.x, p.y, p.radius);
                const dead = p.radius * 0.18;
                if (p.x < -dead) {
                    isMovingLeft = true;
                    isMovingRight = false;
                } else if (p.x > dead) {
                    isMovingRight = true;
                    isMovingLeft = false;
                } else {
                    isMovingLeft = false;
                    isMovingRight = false;
                }
            };

            const handleEnd = () => {
                activeTouchId = null;
                isPointerDown = false;
                isMovingLeft = false;
                isMovingRight = false;
                joystickKnob.style.transform = 'translate(0, 0)';
            };

            // Touch events
            joystick.addEventListener('touchstart', (ev) => {
                if (ev.cancelable) ev.preventDefault();
                const t = ev.changedTouches[0];
                handleStart(t.clientX, t.clientY, t.identifier);
            }, { passive: false });

            joystick.addEventListener('touchmove', (ev) => {
                if (ev.cancelable) ev.preventDefault();
                // find our active touch
                for (let i = 0; i < ev.changedTouches.length; i++) {
                    const t = ev.changedTouches[i];
                    if (activeTouchId === null || t.identifier === activeTouchId) {
                        handleMove(t.clientX, t.clientY);
                        break;
                    }
                }
            }, { passive: false });

            joystick.addEventListener('touchend', (ev) => {
                for (let i = 0; i < ev.changedTouches.length; i++) {
                    if (ev.changedTouches[i].identifier === activeTouchId) {
                        handleEnd();
                        break;
                    }
                }
            });

            joystick.addEventListener('touchcancel', handleEnd);

            // Mouse support for testing on desktop
            joystick.addEventListener('mousedown', (ev) => {
                ev.preventDefault();
                handleStart(ev.clientX, ev.clientY, 'mouse');
                const moveHandler = (me) => handleMove(me.clientX, me.clientY);
                const upHandler = () => { handleEnd(); document.removeEventListener('mousemove', moveHandler); document.removeEventListener('mouseup', upHandler); };
                document.addEventListener('mousemove', moveHandler);
                document.addEventListener('mouseup', upHandler);
            });
        }

        function initializeGame() {
            // Kh√¥i ph·ª•c tr·∫°ng th√°i nh√¢n v·∫≠t t·ª´ localStorage n·∫øu c√≥
            const savedCharacter = localStorage.getItem('currentCharacter');
            const savedLevel = localStorage.getItem('gameLevel');
            if (savedCharacter && savedLevel) {
                currentCharacter = savedCharacter;
                gameLevel = parseInt(savedLevel);
                if (gameLevel > MAX_LEVEL) {
                    gameLevel = 1;
                    currentCharacter = characterProgression[1];
                }
            }

            createLevel(level1Data);
            gameWorld.style.width = level1Data.worldWidth + 'px';

            // C·∫≠p nh·∫≠t h√¨nh ·∫£nh nh√¢n v·∫≠t v√† hi·ªÉn th·ªã level
            player.style.backgroundImage = `url('${currentCharacter}')`;
            updateLevelDisplay();

            playerX = 50;
            // ƒê·∫∑t nh√¢n v·∫≠t ·ªü v·ªã tr√≠ an to√†n: t√¨m platform ngay d∆∞·ªõi v·ªã tr√≠ playerX v√† ƒë·∫∑t ƒë√°y hitbox ch·∫°m b·ªÅ m·∫∑t platform
            const startingPlatform = level1Data.elements.find(e => e.type === 'platform' && playerX >= e.left && playerX < e.left + e.width) || level1Data.elements.find(e => e.type === 'platform');
            if (startingPlatform) {
                const platformTop = startingPlatform.bottom + startingPlatform.height;
                // playerY l√† t·ªça ƒë·ªô ƒë√°y hi·ªÉn th·ªã c·ªßa nh√¢n v·∫≠t, nh∆∞ng hitbox ƒë√°y = playerY + hitboxYOffset
                // Do ƒë√≥ ƒë·ªÉ ƒë√°y hitbox ch·∫°m ƒë√∫ng m·∫∑t platform, ƒë·∫∑t playerY = platformTop - hitboxYOffset
                playerY = platformTop - hitboxYOffset;
                isOnPlatform = true;
            } else {
                // Fallback n·∫øu kh√¥ng t√¨m th·∫•y platform: ƒë·ªÉ nh√¢n v·∫≠t ·ªü v√πng an to√†n m·∫∑c ƒë·ªãnh
                playerY = 50;
                isOnPlatform = false;
            }

            xVelocity = 0;
            yVelocity = 0;
            isJumping = false;
            isMovingLeft = false;
            isMovingRight = false;
            isGameOver = false;

            playerActualWidth = playerBaseWidth;
            playerActualHeight = playerBaseHeight;
            player.classList.remove('crouching', 'in-air', 'flipped');
            facingRight = true;
            cameraX = 0;

            gameMessage.style.display = 'none';

            startTime = performance.now();
            elapsedTime = 0;
            timeDisplay.textContent = 'Th·ªùi gian: 00:00.00';
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 10);

            updatePlayerPosition();

            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
            }
            lastFrameTime = performance.now();
            window.animationFrameId = requestAnimationFrame(gameLoop);
        }

        initializeGame();
    </script>
</body>
</html>
